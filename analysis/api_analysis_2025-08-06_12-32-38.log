
# API Analysis and Improvement Suggestions

## Issues Identified:

1. **Test Data Handling Issue (`test_list_tasks_performance`):**
   - The error `AttributeError: 'FixtureFunctionDefinition' object has no attribute 'copy'` indicates that `sample_task_data` is being used incorrectly in tests
   - Likely the fixture is not being called properly (should be `sample_task_data()` instead of `sample_task_data`)

2. **Partial Update Logic Issue (`test_update_task_partial`):**
   - The error `KeyError: 'status'` suggests problems with partial task updates
   - The current implementation has an issue with how `exclude_unset=True` is used in `model_dump()`
   - When fields are explicitly set to `None` in requests, they might not be properly handled

3. **Redundant Endpoint:**
   - A dedicated endpoint for updating task status (`/tasks/{task_id}/status`) exists when the regular update endpoint can already handle this

## Improvements for the API:

1. **Fix the Partial Update Logic:**
   ```python
   # In update_task function
   update_data = updated_task.model_dump(exclude_none=True)  # Change to exclude_none
   
   # Or if you want to handle explicitly set None values differently:
   update_data = updated_task.model_dump()
   
   for field, value in update_data.items():
       setattr(task, field, value)
   ```

2. **Remove Redundant Endpoint:**
   - Delete the `/tasks/{task_id}/status` endpoint since status updates can be done via the regular update endpoint

3. **Add Timestamps for Task Tracking:**
   ```python
   from datetime import datetime
   
   class TaskBase(BaseModel):
       title: str = Field(..., min_length=1, max_length=100, description='Title of the task')
       description: Optional[str] = Field(None, max_length=500, description='Description of the task')
       priority: TaskPriority = Field(..., description='Priority of the task')
       status: StatusOfTask = Field(StatusOfTask.PENDING, description='Status of the task')
       due_date: FutureDatetime = Field(..., description='Due date of the task')
       created_at: datetime = Field(default_factory=datetime.now, description='Time when task was created')
       updated_at: datetime = Field(default_factory=datetime.now, description='Time when task was last updated')
   ```

4. **Improve Error Handling:**
   ```python
   @app.put("/tasks/{task_id}", response_model=Task)
   def update_task(task_id: UUID, updated_task: TaskUpdate):
       if task_id not in tasks_db:
           raise HTTPException(status_code=404, detail='Task not found')
       
       # Check if at least one field is provided for update
       if not any(updated_task.__dict__.values()):
           raise HTTPException(status_code=400, detail='No fields provided for update')
       
       task = tasks_db[task_id]
       update_data = updated_task.model_dump(exclude_none=True)
       
       # Update timestamp if any field is being changed
       if update_data:
           task.updated_at = datetime.now()
           
       for field, value in update_data.items():
           setattr(task, field, value)
           
       return task
   ```

5. **Add Pagination to List Tasks:**
   ```python
   @app.get("/tasks", response_model=List[Task])
   def list_tasks(
       status: Optional[StatusOfTask] = Query(None),
       priority: Optional[TaskPriority] = Query(None),
       skip: int = Query(0, ge=0, description="Number of records to skip"),
       limit: int = Query(10, ge=1, le=100, description="Maximum number of records to return")
   ):
       results = list(tasks_db.values())
       
       if status is not None:
           results = [t for t in results if t.status == status]
       if priority is not None:
           results = [t for t in results if t.priority == priority]
           
       return results[skip:skip+limit]
   ```

6. **Add Search and Sort Capabilities:**
   ```python
   @app.get("/tasks", response_model=List[Task])
   def list_tasks(
       status: Optional[StatusOfTask] = Query(None),
       priority: Optional[TaskPriority] = Query(None),
       search: Optional[str] = Query(None, description="Search in title and description"),
       skip: int = Query(0, ge=0),
       limit: int = Query(10, ge=1, le=100),
       sort_by: Optional[str] = Query(None, regex="^(created_at|updated_at|priority|due_date)$", description="Field to sort by"),
       sort_order: Optional[str] = Query("asc", regex="^(asc|desc)$", description="Sort order")
   ):
       # ... filtering logic ...
       
       # Add search
       if search:
           search_lower = search.lower()
           results = [t for t in results if search_lower in t.title.lower() or 
                     (t.description and search_lower in t.description.lower())]
       
       # Add sorting
       if sort_by:
           reverse = sort_order == "desc"
           if sort_by in ["created_at", "updated_at"]:
               results = sorted(results, key=lambda x: getattr(x, sort_by), reverse=reverse)
           elif sort_by == "priority":
               results = sorted(results, key=lambda x: x.priority.value, reverse=reverse)
           elif sort_by == "due_date":
               results = sorted(results, key=lambda x: x.due_date, reverse=reverse)
               
       return results[skip:skip+limit]
   ```

7. **Improve Validation for Due Dates:**
   ```python
   class TaskBase(BaseModel):
       # ... other fields ...
       due_date: datetime = Field(..., description='Due date of the task')
       
       @validator('due_date')
       def validate_due_date(cls, v):
           if v <= datetime.now():
               raise ValueError('Due date must be in the future')
           return v
   ```

These improvements would make the API more robust, user-friendly, and maintainable while addressing the test failures.